# λ¨ν¬νΈμ λΉµμ§‘ μ•κ³ λ¦¬μ¦(Lamport's bakery algorithm)
### β‹ μ •μ
```text
μΌλ°μ μΌλ΅ CS μ—μ„λ” μ—¬λ¬ μ¤λ λ“κ°€ λ™μΌν• λ¦¬μ†μ¤μ— λ™μ‹μ— μ•΅μ„Έμ¤ν•λ” κ²ƒμ΄ μΌλ°μ μ΄λ‹¤.
λ‘ μ΄μƒμ μ¤λ λ“κ°€ λ™μΌν• λ©”λ¨λ¦¬ μ„μΉμ— μ ‘κ·Όν•λ ¤κ³  ν•λ©΄ λ‹¤λ¥Έ μ¤λ λ“κ°€ μ“°κΈ°λ¥Ό μ™„λ£ν•κΈ° μ „μ— μ–΄λ–¤ ν• μ¤λ λ“κ°€ λ©”λ¨λ¦¬ μ„μΉ(λ°μ΄ν„°)λ¥Ό μ½λ” κ²½μ° Data corruption(λ°μ΄ν„° μ†μƒ)μ΄ λ°μƒν•  μ μλ‹¤. 
λ¨ν¬νΈμ λΉµμ§‘ μ•κ³ λ¦¬μ¦μ€ λ°μ΄ν„° μ†μƒ μ„ν—μ„ μ κ±°ν•κΈ° μ„ν•΄ λ™μ‹ μ¤λ λ“κ°€ μ½”λ“μ critical sections(μ¤‘μ” μ„Ήμ…)μ— λ™μ‹μ— λ“¤μ–΄κ°€λ” κ²ƒμ„ λ°©μ§€ν•λ„λ΅ μ„¤κ²λ μƒνΈ λ°°μ  μ•κ³ λ¦¬μ¦ μ¤‘ ν•λ‚μ΄λ‹¤.  
```
### β‹ λΉ„μ 
```text
μ‚¬λλ“¤λ΅ λ¶λΉ„λ” λΉµμ§‘μ—μ„ λ²νΈν‘λ¥Ό λ½‘μ•„ λΉµμ„ μ‚¬λ ¤κ³  κΈ°λ‹¤λ¦¬λ” μ‚¬λλ“¤μ— λΉ„μ ν•΄μ„ λ§λ“  μ•κ³ λ¦¬μ¦μ΄λ‹¤.
μ¤€λΉ„ μƒνƒ νμ—μ„ κΈ°λ‹¤λ¦¬λ” ν”„λ΅μ„Έμ¤λ§λ‹¤ μ°μ„ μμ„λ¥Ό λ¶€μ—¬ν•μ—¬ κ·Έμ¤‘ μ°μ„ μμ„κ°€ κ°€μ¥ λ†’μ€ ν”„λ΅μ„Έμ¤μ— λ¨Όμ € ν”„λ΅μ„Έμ„λ¥Ό ν• λ‹Ήν•λ” λ°©λ²•μ΄λ‹¤. 
λΉµμ§‘μ—μ„ λ²νΈν‘λ¥Ό λ°›κ³  κΈ°λ‹¤λ¦¬λ” κ°λ…μ„ μ‚¬μ©ν•μ—¬ 'λ¨ν¬νΈμ λΉµμ§‘ μ•κ³ λ¦¬μ¦'μ΄λΌκ³  ν•λ‹¤.
```
---
`μ•½κ°„μ μμ • λ° κ°€μ •μ΄ ν•„μ”ν•λ‹¤.
μ™λƒν•λ©΄ λ‘ μ΄μƒμ μ¤λ λ“λ¥Ό μ”μ² ν•  λ• λ™μΌν• λ²νΈ n μ„ μ–»μΌλ©΄ μ΄ μƒν™©μ„ ν”Όν•  μ μ—†λ‹¤.
λ”°λΌμ„ μ¤λ λ“ μ‹λ³„μ iλ„ μ°μ„  μμ„λΌκ³  κ°€μ •ν•λ‹¤.
i κ°€ λ‚®μ„ μλ΅ μ°μ„ μμ„κ°€ λ†’μΌλ©° μ°μ„  μμ„κ°€ λ†’μ€ μ¤λ λ“λ” μ„κ³„ μμ—­μ— λ¨Όμ € λ“¤μ–΄κ°„λ‹¤.`
### β‹ ν¬λ¦¬ν‹°μ»¬ μ„Ήμ…(Critical Section)
```texet
critical section μ€ λ¦¬μ†μ¤μ— λ€ν• λ…μ  μ•΅μ„Έμ¤κ°€ ν•„μ”ν•κ³  ν• λ²μ— ν•λ‚μ μ¤λ λ“μ—μ„λ§ μ‹¤ν–‰λ  μ μλ” μ½”λ“ λ¶€λ¶„μ΄λ‹¤.

λΉ„μ λ¥Ό ν•μλ©΄, κ³ κ°κ³Ό λΉµμ§‘ μ§μ›κ³Ό κ±°λν•  λ• λ‹¤λ¥Έ μ‚¬λλ“¤μ€ κΈ°λ‹¤λ ¤μ•Ό ν•λ‹¤.
```
```text
μ! μ¤λ λ“κ°€ critical section μ— λ“¤μ–΄κ°€κ³ μ ν•  λ• μ§€κΈμ΄ κ·Έλ΄ μ°¨λ΅€μΈμ§€ ν™•μΈν•΄μ•Ό ν•λ‹¤.

λ‹¤λ¥Έ λ¨λ“  κ³ κ°μ λ²νΈκ°€ n μ΄λ©° n μ„ ν™•μΈν•μ—¬ μ°μ„ μμ„λ¥Ό ν™•μΈν•΄μ•Ό ν•λ‹¤. λ‹¤λ¥Έ κ³ κ°μ λ²νΈκ°€ n μΌλ΅ κ°™λ‹¤λ©΄ μ¤λ λ“μ μ‹λ³„μ i κ³ μ  λ²νΈλ¥Ό λ‘μ–΄μ„ i κ°€ κ°€μ¥ μ‘μ€ κ°’ 
μ¦‰, μ°μ„  μμ„κ°€ λ†’μ€ i λ¥Ό κ°€μ§„ μ¤λ λ“λ¥Ό λ¨Όμ € critical section μ— μ§„μ…ν•λ‹¤.
ex) [1,1,2,3,4,5]
μ²« λ²μ§Έ κ³ κ°μ λ²νΈμ™€ λ‘ λ²μ§Έ κ³ κ°μ λ²νΈκ°€ 1λ΅ λ™μΌν•λ©΄ ν•΄λ‹Ή μΈλ±μ¤λ΅ νλ‹¨ν•λ‹¤.
```

`μμ‚¬ μ½”λ“`
- A, B : μ¤λ λ“<br>
- n : μ¤λ λ“μ κ³ κ° λ²νΈ<br>
- i : μ¤λ λ“μ μ¤λ λ“ λ²νΈ<br>

μ•„λμ μμ‚¬μ½”λ“λ¥Ό μ‚΄ν΄λ³΄λ©΄ A μ¤λ λ“κ°€ B μ¤λ λ“ λ³΄λ‹¤ μ°μ„ μμ„κ°€ λ†’μ•„ λ¨Όμ € critical section μ— λ“¤μ–΄κ°„λ‹¤.
```text
A(n, i) < B(n, i)
```
μ΄μ λ” μ•„λμ μμ‚¬μ½”λ“ μ΅°κ±΄μ΄ λ§μ΅±ν•΄μ•Ό ν•λ‹¤.<br>
1. B μ¤λ λ“μ κ³ κ° λ²νΈκ°€ A μ¤λ λ“μ κ³ κ° λ²νΈλ³΄λ‹¤ μ°μ„ μμ„κ°€ λ†’λ‹¤.
2. λ§μ•½ κ³ κ° λ²νΈκ°€ κ°™λ‹¤λ©΄, B μ¤λ λ“μ μ‹λ³„μ i κ°€ A μ¤λ λ“μ μ‹λ³„μ i λ³΄λ‹¤ μ°μ„ μμ„κ°€ λ†’μ•„μ•Ό ν•λ‹¤.
```text
A(n) < B(n) λλ”
A(n) == B(n) λ° A(i) < B(i)
```
### β‹ μ¤‘μ”ν•μ§€ μ•μ€ μ„Ήμ…(Non-critical Section)
```text
Non-critical Section μ€ λ…μ  μ•΅μ„Έμ¤κ°€ ν•„μ”ν•μ§€ μ•μ€ μ½”λ“ λ¶€λ¶„μ΄λ‹¤.
λ‹¤λ¥Έ μ¤λ λ“μ λ¦¬μ†μ¤ λ° μ‹¤ν–‰μ„ λ°©ν•΄ν•μ§€ μ•λ” μΌλ¶€ μ¤λ λ“λ³„ κ³„μ‚°μ„ λ‚νƒ€λ‚Έλ‹¤.

λΉ„μ λ¥Ό ν•μλ©΄, μ§€κ°‘μ— κ±°μ¤λ¦„λμ„ λ‹¤μ‹ λ„£λ” κ²ƒκ³Ό μ μ‚¬ν•λ‹¤.
```
---
## π€ μ•κ³ λ¦¬μ¦ κµ¬ν„
### μ΅°κ±΄
```text
1. λ‘ κ° μ΄μƒμ ν”„λ΅μ„Έμ¤κ°€ λ™μ‘ν•κ³  μμ„ κ²½μ°
2. κ°€μ¥ λ‚®μ€ λ²νΈ μ¦‰, μ°μ„ μμ„κ°€ λ†’μ€ λ²νΈλ¥Ό λ°›μ€ ν”„λ΅μ„Έμ¤κ°€ κ°€μ¥ λ¨Όμ € μ„κ³„ μμ—­μ— λ“¤μ–΄κ° μ μμ.
3. λ²νΈ λ¶€μ—¬λ” μ¦κ°€ν•λ” λ°©μ‹μΌλ΅ ν•μ§€λ§ μ°μ—°ν κ°™μ€ λ²νΈλ¥Ό λ°›μ„ μ μμΌλ‹ μ΄λ΄ λ•λ” μ¤λ λ“μ κ³ μ  λ²νΈ(μ‹λ³„μ)λ΅ μ§„ν–‰ν•μ.
```
β¶
```text
μ°μ„  μ²« λ²μ§Έλ΅, κ³µμ  μμ›μ„ λ§λ“ λ‹¤.

μ€ν–‰μΌλ΅ μμ‹λ¥Ό λ“¤λ©΄ isWaitionNumber λ” λ²νΈν‘λ¥Ό λ°›μ•λ” μ§€ μ•λ°›μ•λ” μ§€ ν™•μΈν•λ” κ³µμ  λ³€μμ΄κ³  
number λ” κ°κ°μ μ‚¬λλ“¤μ λ²νΈν‘λ¥Ό λ°›κ³  λ¶€μ—¬λ°›μ€ λ²νΈμ κ³µμ  λ³€μ.
κ·Έλμ„ μ°λ¦¬λ” idx μ¦‰, μ‚¬λλ“¤ λ²νΈν‘λ¥Ό λ¶€μ—¬λ°›μ„ μ‚¬λλ“¤μ μΈμ› μ λ§νΌ μ „μ—­ λ³€μλ΅ μ΄κΈ°κ°’μ„ μ„¤μ •ν•΄μ•Όν•λ‹¤.
```
```kotlin
class Bank(
    val idx: Int
){
    var isWaitingNumber = mutableListOf<Boolean>() 
    var number = mutableListOf<Int>() 

    fun getGlobalValue(){
        for (i in 0 until idx){
            isWaitingNumber.add(i, false)
            number.add(i, 0)
        }
    }
}

```
β· 
```text
λ¶€μ—¬ λ°›μ€ λ²νΈ μ¤‘ κ°€μ¥ ν° λ²νΈ +1 λ°ν™

μλ¥Ό λ“¤λ©΄, 10λ…μ μ‚¬λμ΄ μ•„λ¬΄λ„ λ²νΈλ¥Ό λ¶€μ—¬λ°›μ§€ λ»ν•¨. κ·Έλ¬λ©΄ 0λ²μ§Έ μ‚¬λμ΄ μ™”μ„ λ•, dafault λ΅ 0μΌλ΅ λ¨λ‘ λμ–΄μκ³ , 
μ—¬κΈ°μ„ λ²νΈλ¥Ό λ¶€μ—¬λ°›μ„ λ• +1 μ΄ λμ–΄μ„ λ²νΈ 1μ„ λ°›λ”λ‹¤.
```
```kotlin
fun maxNumber(num: MutableList<Int>): Int{
    var n = 0
    num.forEach {
        if (it > n){
            n = it
        }
    }
    return n + 1
}
```
βΈ 
```text
lock ν•¨μ λ§λ“¤κΈ°

i λ²μ§Έ μ‚¬λμ—κ² λ²νΈν‘ λ¶€μ—¬ ν•κ³  λ²νΈν‘μ λ²νΈ λ¶€μ—¬ν•κ³ 
λ€κΈ° μƒνƒκ°€ μ΅΄μ¬ν•λ”λ°,
μ „μ²΄μ λ²νΈλ¥Ό λ¶€μ—¬ λ°›μ€ κ°’μ„ νλ‹¨ν•΄μ„ λ€κΈ° μƒνƒλ¥Ό ν•  μ§€ μ•ν• μ§€ νλ‹¨ν•λ‹¤.
λ€κΈ° μƒνƒλ¥Ό λ²—μ–΄λ‚λ” μ΅°κ±΄μ€ i λ²μ§Έ μ‚¬λ μ΄μ™Έμ— λ²νΈν‘λ¥Ό λ°›κ³  μμ§€ μ•μ„ λ•μ™€ i λ²μ§Έ μ‚¬λλ³΄λ‹¤ μ°μ„ μμ„κ°€ λ†’μ€ μ‚¬λμ΄ μ—†μ„ λ•μ΄λ‹¤.
λ§μ•½μ— μ„ μ΅°κ±΄μ„ λ§μ΅±ν•λ” κ²ƒμ΄ μλ‹¤λ©΄ λ€κΈ°μƒνƒλ΅ λΉ μ§„λ‹¤.
```
```kotlin
fun lock(i: Int){
    isWaitingNumber[i] = true 
    number[i] = maxNumber(number) 
    isWaitingNumber[i] = false 

    for (j in 0 until number.size){
        while (isWaitingNumber[j]){}
        while ((number[j] != 0) && (number[j] < number[i]) || (number[j] == number[i] && j < i)){}
    }
}
```
βΉ
```text
unlock ν•¨μ λ§λ“¤κΈ°

λ§μ•½ λ‚΄ λ²νΈκ°€ n κ°μ ν”„λ΅μ„Έμ¤λ“¤μ λ²νΈ μ¤‘ κ°€μ¥ μ‘λ‹¤λ©΄ λ²νΈλ¥Ό 0 μΌλ΅ λ°”κΏ => μ„κ³„ μμ—­ μ‚¬μ© μ™„λ£(μμ› μ‚¬μ© X)
ex) 0λ²μ§Έμ μ‚¬λμ λ²νΈν‘ λ²νΈκ°€ 0μΌλ΅ λ°”λ€” μ‹ 0λ²μ§Έ μ‚¬λμ€ μ„κ³„μμ—­μ„ μ‚¬μ©ν•  μ΄μ κ°€ μ—†μ
```
```kotlin
fun unlock(i: Int){
    number[i] = 0
}
```
---
### Reference
[Wikipedia : Lamport Bakery algorithm](https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm)<br>
[tistory_giantpark197cm Blog : Lamport Bakery algorithm](https://giantpark197cm.tistory.com/209)<br>
[tistory_yoongrammer : Lamport Bakery algorithm](https://yoongrammer.tistory.com/61)