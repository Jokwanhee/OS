# 데커 알고리즘(Dekker Algorithm)
`우선 알아야할 것은 데커 알고리즘은 상호배제를 해결하는 다양한 방법이다. 즉, 병행 프로그래밍의 상호배제 문제를 풀 수 있는 해결책이다.`<br>

## 데커 알고리즘

### 용어 정리
```text
🚀 병행 프로세스란?
: 프로세서 하나는 한 번에 프로세스 하나만 실행할 수 있다. 하지만 운영체제가 프로세서를 빠르게 전환하여 
프로세서 시간을 나눠서 마치 프로세스 여러 개를 동시에 실행하는 것처럼 보이게 하는 것을 병행 프로세스라고 한다.

🚀 상호배제란?
: 병행 프로세스에서 프로세스 하나가 공유 자원(임계 자원)을 사용할 때 다른 프로세스들이 동일한 일을 할 수 없도록 하는 방법

🚀 임계 영역이란?
: 다수의 프로세스가 접근할 수 있지만, 어느 한순간에는 프로세스 하나만 사용할 수 있다. 
어떤 프로세스가 임계 영역에 들어가면 다른 프로세스는 임계 영역에 들어갈 수 없다.
```
### 정의
```text
🎯 데커 알고리즘이란?
소프트웨어로 상호배제를 해결하는 방법으로 두 프로세스가 서로 통신하려고 공유 메모리를 사용하여 충돌 없이 
단일 자원을 공유할 수 있도록 허용하는 알고리즘이다.
```
### 조건
```text
1. 두 프로세스가 동시에 임계 영역에 진입하려고 시도하면 순서에 따라 오직 하나만 임계영역에 들어가도록 허용한다.  
2. 각 프로세스는 플래그를 설정하여 그 플래그에 맞게 차례를 기다린다.
```

### 코드 설명하기
`Explain`
```text
짱구 : 프로세스 #1
철수 : 프로세스 #2
화장실 : 임계 영역

공유자원
flag 의 초기값은 flag[0] = flag[1] = false 로 진행하며 
turn 로 값 변경 시 프로세스가 임계 영역에 들어간다는 사실을 알리게 된다.

flag[0] = true : 짱구가 화장실을 들어간다는 사실을 알림.
flag[1] = true : 철수가 화장시을 들어간다는 사실을 알림. 

turn : 짱구와 철수가 동시에 화장실에 들어가려고 충돌하는 것을 방지하는 공유 변수
    - 0 : 짱구 순서
    - 1 : 철수 순서

```
```text
짱구와 철수가 동시에 화장실에 진입하려고 한다.
(1) turn = 0 으로 짱구의 순서로 초기 값 설정
(2) 짱구가 화장실 노크를 하고 동시에 철수도 화장실을 노크한다.
(3) 짱구의 순서이므로 짱구가 안에 들어간다. -> 철수 대기
(4) 짱구가 화장실에 나오고 철수가 화장실에 다시 들어감.
(5) 다시 짱구는 화장실을 노크한다.
(6) 철수가 화장실에 있으니 -> 짱구 대기
(7) 철수가 화장실에서 나오고 짱구가 화장실에 다시 들어감.
위와 같은 상황이 계속해서 반복된다.

여기서 주목해야 할 점은 위에서 언급한 조건에 충족했냐? 이다
1. 두 프로세스(짱구와 철수)가 동시에 임계 영역(화장실)에 진입(노크)하려고 했고, 
순서(turn)에 따라서 오직 하나만 임계 영역(화장실)에 진입하였다.
2. 각 flag를 설정하여 두 프로세스(짱구와 철수)가 임계 영역(화장실)에 들어갔는 지 확인하며 순서(turn) 을 확인하며 
프로세스(짱구 및 철수)를 대기시킬 것인지 프로세스(짱구 및 철수)를 임계 영역(화장실)으로 넣을 것인지 순서를 정하였다.

위 두 조건을 만족하여 아래의 Kotlin 코드로 Dekker Algorithm 을 프로그래밍으로 구현해보았다.
```
`Algorithm`
```kotlin
// 공유 자원
var flag = mutableMapOf(0 to false, 1 to false) 
var turn = 0

// Process #1
inner class Thread1: Thread(){
    override fun run() {
        super.run()
        while (true) {
            flag[0] = true

            while (flag[1] == true){
                if (turn == 1){
                    flag[0] = false
                    while (turn == 1){
                        // 대기
                    }
                    flag[0] = true
                }
            }
            turn = 1
            flag[0] = false
        }
    }
}

// Process #2
inner class Thread2: Thread(){
    override fun run() {
        super.run()

        while (true){
            flag[1] = true
            while (flag[0] == true){
                if (turn == 0){
                    flag[1] = false
                    while (turn == 0){
                        // 대기
                    }
                    flag[1] = true 
                }
            }
            turn = 0
            flag[1] = false
        }
    }
}


```

`Kotlin Code Example`
```kotlin

class ProgramClass(){
    // 두 프로세스가 통신하기 위해 공유 메모리를 사용하여 충돌 없이 단일 자원을 공유할 수 있다.
    var flag = mutableMapOf(0 to false, 1 to false) // flag[0] = false, flag[1] = false
    var turn = 0 // 짱구 순서

    inner class Thread1: Thread(){
        override fun run() {
            super.run()
            while (true) {
                println("짱구 화장실 노크...")
                flag[0] = true // 짱구가 화장실 노크!
                sleep(500)

                // (1) 짱구 노크 + 철수는 화장실
                while (flag[1] == true){ // 철수가 화장실에 있나?
                    if (turn == 1){ // 철수 순서이면 철수가 안에 있다는 것이 확인
                        println("철수가 안에 있어요")
                        flag[0] = false // 짱구는 화장실 밖에서 대기

                        // turn == 1 즉, 철수의 순서
                        while (turn == 1){ // 계속해서 철수가 화장실 안에있고 철수의 순서라면
                            println("짱구 기다리는 중..") // 짱구 대기
                            sleep(1000)
                        }
                        println("짱구 화장실 노크...")
                        // turn == 0 즉, 짱구의 순서
                        flag[0] = true // 철수의 순서 즉, turn = 0 으로 변경 시 짱구의 순서가 되었을 때, 다시 짱구는 화장실에 노크를 한다.
                    }
                }

                // (2) 짱구 노크 + 화장실 아무도 없음
                // 철수가 화장실에 들어가지 않았다면 짱구는 화장실에 들어간다.
                println("짱구 화장실 들어감.")
                sleep(2000)

                // 순서가 철수의 순서로 변경되었으며
                turn = 1
                // 짱구가 화장실을 나옴.
                flag[0] = false
                println("짱구 화장실에서 나옴.")
                // 해당 sleep 을 주는 이유는 짱구가 화장실에서 나왔을 때 철수가 들어가야하는데, 짱구가 노크를 하고 짱구가 다시 들어가는 것을 방지
                sleep(1000)
            }
        }
    }

    // 내부 클래스로 상위 클래스인 ProgramClass 의 전역변수의 메모리를 공유 받을 수 있다.
    inner class Thread2: Thread(){
        override fun run() {
            super.run()

            while (true){
                println("철수 화장실 노크...")
                flag[1] = true // 철수가 화장실을 노크한다.
                sleep(500)
                while (flag[0] == true){ // 짱구가 화장실에 있나?
                    if (turn == 0){ // 순서는 짱구의 순서
                        println("짱구가 안에 있어요.")
                        flag[1] = false // 철수가 화장실 노크를 중단하고 기다리기
                        while (turn == 0){ // 짱구의 순서 동안에 철수는 기다린다
                            println("철수가 기다리는 중...") // 철수 대기
                            sleep(1000)
                        }
                        flag[1] = true // turn = 1 즉, 철수의 순서이므로 철수는 화장실에 노크를 다시 한다.
                    }
                }

                // flag[0] == false 즉, 짱구는 화장실에 없다. 그렇기 때문에 철수는 화장실에 들어간다.
                println("철수 화장실 들어감.")
                sleep(2000)

                // 순서는 짱구의 순서로 변경
                turn = 0
                // 철수는 화장실에서 나온다.
                flag[1] = false
                println("철수 화장실에서 나옴.")
                // 해당 sleep 을 주는 이유는 철수가 화장실에서 나왔을 때 짱구가 들어가야하는데, 철수가가 노크를 하고 철수가 다시 들어가는 것을 방지
                sleep(1000)
            }
        }
    }
}




fun main(){
    val programClass = ProgramClass()

    val thread1 = programClass.Thread1()
    val thread2 = programClass.Thread2()

    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
}
```
`OUTPUT`
```kotlin
짱구 화장실 노크...
철수 화장실 노크...
짱구가 안에 있어요.
짱구 화장실 들어감.
철수가 기다리는 중...
철수가 기다리는 중...
짱구 화장실에서 나옴.
철수 화장실 들어감.
짱구 화장실 노크...
철수가 안에 있어요
짱구 기다리는 중..
철수 화장실에서 나옴.
짱구 화장실 노크...
짱구 화장실 들어감.
철수 화장실 노크...
짱구가 안에 있어요.
철수가 기다리는 중...
짱구 화장실에서 나옴.
철수 화장실 들어감.
짱구 화장실 노크...
철수가 안에 있어요
짱구 기다리는 중..
철수 화장실에서 나옴.
짱구 화장실 노크...
짱구 화장실 들어감.
철수 화장실 노크...
...
```